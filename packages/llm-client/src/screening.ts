import type { UserProfile, ScreeningAnswerRequest, ScreeningAnswerResponse } from '@jobslave/shared';
import { LMStudioClient } from './client';
import { createProfileSystemPrompt, createScreeningQuestionPrompt, createExperienceExtractionPrompt } from './prompts';

export class ScreeningAnswerService {
  private client: LMStudioClient;
  private profile: UserProfile | null = null;
  private systemPrompt: string = '';

  constructor(client: LMStudioClient) {
    this.client = client;
  }

  setProfile(profile: UserProfile): void {
    this.profile = profile;
    this.systemPrompt = createProfileSystemPrompt(profile);
  }

  async answerQuestion(request: ScreeningAnswerRequest): Promise<ScreeningAnswerResponse> {
    if (!this.profile) {
      throw new Error('Profile not set. Call setProfile() first.');
    }

    const { question, questionType, options, jobTitle, jobCompany } = request;

    // First, try to handle common questions with direct profile data
    const directAnswer = this.tryDirectAnswer(question, questionType, options);
    if (directAnswer) {
      return {
        answer: directAnswer,
        confidence: 1.0,
        reasoning: 'Answered directly from profile data',
      };
    }

    // For experience-related questions, try to match with skills
    if (this.isExperienceQuestion(question)) {
      const experienceAnswer = await this.handleExperienceQuestion(question, questionType);
      if (experienceAnswer) {
        return experienceAnswer;
      }
    }

    // Use LLM for complex questions
    const userPrompt = createScreeningQuestionPrompt(
      question,
      questionType,
      options,
      jobTitle,
      jobCompany
    );

    const answer = await this.client.generateWithSystemPrompt(
      this.systemPrompt,
      userPrompt,
      { temperature: 0.3 } // Lower temperature for more consistent answers
    );

    // Post-process the answer
    const processedAnswer = this.postProcessAnswer(answer.trim(), questionType, options);

    return {
      answer: processedAnswer,
      confidence: 0.8,
      reasoning: 'Generated by LLM based on profile',
    };
  }

  private tryDirectAnswer(
    question: string,
    questionType: string,
    options?: string[]
  ): string | null {
    const q = question.toLowerCase();

    // Notice period questions
    if (q.includes('notice period') || q.includes('joining time')) {
      const noticePeriodMap: Record<string, string[]> = {
        immediate: ['immediate', '0', 'immediately', 'right away'],
        '15_days': ['15 days', '15', '2 weeks', 'two weeks'],
        '30_days': ['30 days', '30', '1 month', 'one month', '4 weeks'],
        '60_days': ['60 days', '60', '2 months', 'two months', '8 weeks'],
        '90_days': ['90 days', '90', '3 months', 'three months', '12 weeks'],
        more_than_90_days: ['more than 90', 'more than 3 months', '90+'],
      };

      if (options && options.length > 0) {
        // Find matching option
        const variations = noticePeriodMap[this.profile!.noticePeriod] || [];
        for (const opt of options) {
          const optLower = opt.toLowerCase();
          for (const variation of variations) {
            if (optLower.includes(variation)) {
              return opt;
            }
          }
        }
        // Return first matching option or first option
        return options[0];
      }

      // Text answer
      return this.profile!.noticePeriod === 'immediate'
        ? 'Immediate'
        : this.profile!.noticePeriod.replace('_', ' ');
    }

    // Total experience
    if (q.includes('total experience') || q.includes('years of experience') && !this.isSpecificSkillQuestion(q)) {
      if (questionType === 'number') {
        return String(this.profile!.totalExperience);
      }
      return `${this.profile!.totalExperience} years`;
    }

    // Current CTC
    if (q.includes('current ctc') || q.includes('current salary') || q.includes('present ctc')) {
      if (questionType === 'number') {
        return String(this.profile!.currentCTC || 0);
      }
      return this.profile!.currentCTC ? `${this.profile!.currentCTC} LPA` : 'Not disclosed';
    }

    // Expected CTC
    if (q.includes('expected ctc') || q.includes('expected salary') || q.includes('salary expectation')) {
      if (questionType === 'number') {
        return String(this.profile!.expectedCTC || 0);
      }
      return this.profile!.expectedCTC ? `${this.profile!.expectedCTC} LPA` : 'Negotiable';
    }

    // Location preference
    if (q.includes('preferred location') || q.includes('work location')) {
      if (options && options.length > 0) {
        // Find matching location in options
        for (const opt of options) {
          for (const loc of this.profile!.preferredLocations) {
            if (opt.toLowerCase().includes(loc.toLowerCase())) {
              return opt;
            }
          }
        }
      }
      return this.profile!.preferredLocations[0] || 'Flexible';
    }

    // Willing to relocate
    if (q.includes('willing to relocate') || q.includes('open to relocation')) {
      return this.profile!.willingToRelocate ? 'Yes' : 'No';
    }

    // Work mode
    if (q.includes('work mode') || q.includes('remote') || q.includes('work from')) {
      const modeMap: Record<string, string[]> = {
        remote: ['remote', 'wfh', 'work from home'],
        hybrid: ['hybrid', 'flexible'],
        onsite: ['onsite', 'office', 'in-office'],
        any: ['any', 'flexible', 'open to all'],
      };

      if (options && options.length > 0) {
        const variations = modeMap[this.profile!.preferredWorkMode] || [];
        for (const opt of options) {
          for (const variation of variations) {
            if (opt.toLowerCase().includes(variation)) {
              return opt;
            }
          }
        }
      }
      return this.profile!.preferredWorkMode;
    }

    return null;
  }

  private isExperienceQuestion(question: string): boolean {
    const q = question.toLowerCase();
    return (
      q.includes('experience') ||
      q.includes('years') ||
      q.includes('worked with') ||
      q.includes('proficiency')
    );
  }

  private isSpecificSkillQuestion(question: string): boolean {
    const skills = this.profile!.skills.map(s => s.name.toLowerCase());
    const q = question.toLowerCase();
    return skills.some(skill => q.includes(skill));
  }

  private async handleExperienceQuestion(
    question: string,
    questionType: string
  ): Promise<ScreeningAnswerResponse | null> {
    // Try to extract the skill being asked about
    const q = question.toLowerCase();

    for (const skill of this.profile!.skills) {
      if (q.includes(skill.name.toLowerCase())) {
        const years = skill.yearsOfExperience;
        if (questionType === 'number') {
          return {
            answer: String(years),
            confidence: 1.0,
            reasoning: `Matched skill "${skill.name}" from profile`,
          };
        }
        return {
          answer: `${years} years`,
          confidence: 1.0,
          reasoning: `Matched skill "${skill.name}" from profile`,
        };
      }
    }

    // If no direct match, try to use LLM to extract the skill name
    try {
      const skillName = await this.client.generateText(
        createExperienceExtractionPrompt(question),
        { temperature: 0.1, max_tokens: 50 }
      );

      const matchedSkill = this.profile!.skills.find(
        s => s.name.toLowerCase() === skillName.toLowerCase().trim()
      );

      if (matchedSkill) {
        const years = matchedSkill.yearsOfExperience;
        return {
          answer: questionType === 'number' ? String(years) : `${years} years`,
          confidence: 0.9,
          reasoning: `LLM extracted skill "${skillName}", matched to profile`,
        };
      }
    } catch {
      // Fall through to LLM-based answer
    }

    return null;
  }

  private postProcessAnswer(
    answer: string,
    questionType: string,
    options?: string[]
  ): string {
    // Clean up the answer
    let processed = answer.replace(/^["']|["']$/g, '').trim();

    // For number questions, extract just the number
    if (questionType === 'number') {
      const match = processed.match(/\d+(\.\d+)?/);
      return match ? match[0] : '0';
    }

    // For select/radio, ensure answer matches an option
    if ((questionType === 'select' || questionType === 'radio') && options) {
      const lowerAnswer = processed.toLowerCase();
      const matchedOption = options.find(
        opt => opt.toLowerCase() === lowerAnswer || opt.toLowerCase().includes(lowerAnswer)
      );
      return matchedOption || options[0];
    }

    return processed;
  }
}
